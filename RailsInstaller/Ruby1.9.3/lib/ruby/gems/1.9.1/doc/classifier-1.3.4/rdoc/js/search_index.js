var search_data = {"index":{"searchIndex":["array","classifier","bayes","contentnode","lsi","wordlist","gsl","matrix","vector","matrix","object","string","vector","<<()","sv_decomp()","[]()","[]=()","_dump()","_load()","add_category()","add_item()","add_word()","append_category()","build_index()","categories_for()","classifications()","classify()","classify()","clean_word_hash()","diag()","find_related()","highest_ranked_stems()","highest_relative_content()","items()","magnitude()","method_missing()","needs_rebuild?()","new()","new()","new()","new()","normalize()","paragraph_summary()","prepare_category_name()","proximity_array_for_content()","proximity_norms_for_content()","raw_vector_with()","remove_item()","search()","search_norm()","search_vector()","size()","split_paragraphs()","split_sentences()","sum()","summary()","train()","untrain()","without_punctuation()","word_for_index()","word_hash()"],"longSearchIndex":["array","classifier","classifier::bayes","classifier::contentnode","classifier::lsi","classifier::wordlist","gsl","gsl::matrix","gsl::vector","matrix","object","string","vector","classifier::lsi#<<()","matrix#sv_decomp()","classifier::wordlist#[]()","matrix#[]=()","gsl::vector#_dump()","gsl::vector::_load()","classifier::bayes#add_category()","classifier::lsi#add_item()","classifier::wordlist#add_word()","classifier::bayes#append_category()","classifier::lsi#build_index()","classifier::lsi#categories_for()","classifier::bayes#classifications()","classifier::bayes#classify()","classifier::lsi#classify()","string#clean_word_hash()","matrix::diag()","classifier::lsi#find_related()","classifier::lsi#highest_ranked_stems()","classifier::lsi#highest_relative_content()","classifier::lsi#items()","vector#magnitude()","classifier::bayes#method_missing()","classifier::lsi#needs_rebuild?()","classifier::bayes::new()","classifier::contentnode::new()","classifier::lsi::new()","classifier::wordlist::new()","vector#normalize()","string#paragraph_summary()","object#prepare_category_name()","classifier::lsi#proximity_array_for_content()","classifier::lsi#proximity_norms_for_content()","classifier::contentnode#raw_vector_with()","classifier::lsi#remove_item()","classifier::lsi#search()","classifier::contentnode#search_norm()","classifier::contentnode#search_vector()","classifier::wordlist#size()","string#split_paragraphs()","string#split_sentences()","array#sum()","string#summary()","classifier::bayes#train()","classifier::bayes#untrain()","string#without_punctuation()","classifier::wordlist#word_for_index()","string#word_hash()"],"info":[["Array","","Array.html","",""],["Classifier","","Classifier.html","","<p>Author &mdash; Lucas Carlson  (lucas@rufy.com)\n<p>Copyright &mdash; Copyright © 2005 Lucas Carlson\n<p>License &mdash; LGPL\n"],["Classifier::Bayes","","Classifier/Bayes.html","",""],["Classifier::ContentNode","","Classifier/ContentNode.html","","<p>This is an internal data structure class for the LSI node. Save for \nraw_vector_with, it should be fairly …\n"],["Classifier::LSI","","Classifier/LSI.html","","<p>This class implements a Latent Semantic Indexer, which can search, classify\nand cluster data based on …\n"],["Classifier::WordList","","Classifier/WordList.html","","<p>This class keeps a word =&gt; index mapping. It is used to map stemmed\nwords to dimensions of a vector. …\n"],["GSL","","GSL.html","",""],["GSL::Matrix","","GSL/Matrix.html","",""],["GSL::Vector","","GSL/Vector.html","",""],["Matrix","","Matrix.html","",""],["Object","","Object.html","",""],["String","","String.html","","<p>These are extensions to the String class to provide convenience  methods\nfor the Classifier package. …\n"],["Vector","","Vector.html","",""],["<<","Classifier::LSI","Classifier/LSI.html#method-i-3C-3C","( item )","<p>A less flexible shorthand for add_item that assumes  you are passing in a\nstring with no categorries. …\n"],["SV_decomp","Matrix","Matrix.html#method-i-SV_decomp","(maxSweeps = 20)",""],["[]","Classifier::WordList","Classifier/WordList.html#method-i-5B-5D","(lookup)","<p>Returns the dimension of the word or nil if the word is not in the space.\n"],["[]=","Matrix","Matrix.html#method-i-5B-5D-3D","(i,j,val)",""],["_dump","GSL::Vector","GSL/Vector.html#method-i-_dump","(v)",""],["_load","GSL::Vector","GSL/Vector.html#method-c-_load","(arr)",""],["add_category","Classifier::Bayes","Classifier/Bayes.html#method-i-add_category","(category)","<p>Allows you to add categories to the classifier. For example:\n\n<pre>b.add_category &quot;Not spam&quot;</pre>\n<p>WARNING: Adding …\n"],["add_item","Classifier::LSI","Classifier/LSI.html#method-i-add_item","( item, *categories, &block )","<p>Adds an item to the index. item is assumed to be a string, but  any item\nmay be indexed so long as it …\n"],["add_word","Classifier::WordList","Classifier/WordList.html#method-i-add_word","(word)","<p>Adds a word (if it is new) and assigns it a unique dimension.\n"],["append_category","Classifier::Bayes","Classifier/Bayes.html#method-i-append_category","(category)",""],["build_index","Classifier::LSI","Classifier/LSI.html#method-i-build_index","( cutoff=0.75 )","<p>This function rebuilds the index if needs_rebuild? returns true. For very\nlarge document spaces, this …\n"],["categories_for","Classifier::LSI","Classifier/LSI.html#method-i-categories_for","(item)","<p>Returns the categories for a given indexed items. You are free to add and\nremove items from this as you …\n"],["classifications","Classifier::Bayes","Classifier/Bayes.html#method-i-classifications","(text)","<p>Returns the scores in each category the provided <code>text</code>. E.g.,\n\n<pre>b.classifications &quot;I hate bad words and you&quot; ...</pre>\n"],["classify","Classifier::Bayes","Classifier/Bayes.html#method-i-classify","(text)","<p>Returns the classification of the provided <code>text</code>, which is one\nof the  categories given in the initializer. …\n"],["classify","Classifier::LSI","Classifier/LSI.html#method-i-classify","( doc, cutoff=0.30, &block )","<p>This function uses a voting system to categorize documents, based on  the\ncategories of other documents. …\n"],["clean_word_hash","String","String.html#method-i-clean_word_hash","()","<p>Return a word hash without extra punctuation or short symbols, just stemmed\nwords\n"],["diag","Matrix","Matrix.html#method-c-diag","(s)",""],["find_related","Classifier::LSI","Classifier/LSI.html#method-i-find_related","( doc, max_nearest=3, &block )","<p>This function takes content and finds other documents that are semantically\n“close”, returning …\n"],["highest_ranked_stems","Classifier::LSI","Classifier/LSI.html#method-i-highest_ranked_stems","( doc, count=3 )","<p>Prototype, only works on indexed documents. I have no clue if this is going\nto work, but in theory it’s …\n"],["highest_relative_content","Classifier::LSI","Classifier/LSI.html#method-i-highest_relative_content","( max_chunks=10 )","<p>This method returns max_chunks entries, ordered by their average semantic\nrating. Essentially, the average …\n"],["items","Classifier::LSI","Classifier/LSI.html#method-i-items","()","<p>Returns an array of items that are indexed.\n"],["magnitude","Vector","Vector.html#method-i-magnitude","()",""],["method_missing","Classifier::Bayes","Classifier/Bayes.html#method-i-method_missing","(name, *args)","<p>Provides training and untraining methods for the categories specified in\nBayes#new For example:\n\n<pre>b = Classifier::Bayes.new ...</pre>\n"],["needs_rebuild?","Classifier::LSI","Classifier/LSI.html#method-i-needs_rebuild-3F","()","<p>Returns true if the index needs to be rebuilt.  The index needs to be built\nafter all informaton is added, …\n"],["new","Classifier::Bayes","Classifier/Bayes.html#method-c-new","(*categories)","<p>The class can be created with one or more categories, each of which will be\ninitialized and given a training …\n"],["new","Classifier::ContentNode","Classifier/ContentNode.html#method-c-new","( word_hash, *categories )","<p>If text_proc is not specified, the source will be duck-typed via\nsource.to_s\n"],["new","Classifier::LSI","Classifier/LSI.html#method-c-new","(options = {})","<p>Create a fresh index. If you want to call #build_index manually, use\n\n<pre>Classifier::LSI.new :auto_rebuild ...</pre>\n"],["new","Classifier::WordList","Classifier/WordList.html#method-c-new","()",""],["normalize","Vector","Vector.html#method-i-normalize","()",""],["paragraph_summary","String","String.html#method-i-paragraph_summary","( count=1, separator=\" [...] \" )",""],["prepare_category_name","Object","Object.html#method-i-prepare_category_name","()",""],["proximity_array_for_content","Classifier::LSI","Classifier/LSI.html#method-i-proximity_array_for_content","( doc, &block )","<p>This function is the primitive that find_related and classify  build upon.\nIt returns an array of 2-element …\n"],["proximity_norms_for_content","Classifier::LSI","Classifier/LSI.html#method-i-proximity_norms_for_content","( doc, &block )","<p>Similar to proximity_array_for_content, this function takes similar\narguments and returns a similar array. …\n"],["raw_vector_with","Classifier::ContentNode","Classifier/ContentNode.html#method-i-raw_vector_with","( word_list )","<p>Creates the raw vector out of word_hash using word_list as the key for\nmapping the vector space.\n"],["remove_item","Classifier::LSI","Classifier/LSI.html#method-i-remove_item","( item )","<p>Removes an item from the database, if it is indexed.\n"],["search","Classifier::LSI","Classifier/LSI.html#method-i-search","( string, max_nearest=3 )","<p>This function allows for text-based search of your index. Unlike other\nfunctions like find_related and …\n"],["search_norm","Classifier::ContentNode","Classifier/ContentNode.html#method-i-search_norm","()","<p>Use this to fetch the appropriate search vector in normalized form.\n"],["search_vector","Classifier::ContentNode","Classifier/ContentNode.html#method-i-search_vector","()","<p>Use this to fetch the appropriate search vector.\n"],["size","Classifier::WordList","Classifier/WordList.html#method-i-size","()","<p>Returns the number of words mapped.\n"],["split_paragraphs","String","String.html#method-i-split_paragraphs","()",""],["split_sentences","String","String.html#method-i-split_sentences","()",""],["sum","Array","Array.html#method-i-sum","(identity = 0, &block)",""],["summary","String","String.html#method-i-summary","( count=10, separator=\" [...] \" )",""],["train","Classifier::Bayes","Classifier/Bayes.html#method-i-train","(category, text)","<p>Provides a general training method for all categories specified in\nBayes#new For example:\n\n<pre>b = Classifier::Bayes.new ...</pre>\n"],["untrain","Classifier::Bayes","Classifier/Bayes.html#method-i-untrain","(category, text)","<p>Provides a untraining method for all categories specified in Bayes#new Be\nvery careful with this method. …\n"],["without_punctuation","String","String.html#method-i-without_punctuation","()","<p>Removes common punctuation symbols, returning a new string.  E.g.,\n\n<pre>&quot;Hello (greeting's), with {braces} ...</pre>\n"],["word_for_index","Classifier::WordList","Classifier/WordList.html#method-i-word_for_index","(ind)",""],["word_hash","String","String.html#method-i-word_hash","()","<p>Return a Hash of strings =&gt; ints. Each word in the string is stemmed,\ninterned, and indexes to its …\n"]]}}